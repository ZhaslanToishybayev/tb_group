"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-intersection-observer";
exports.ids = ["vendor-chunks/react-intersection-observer"];
exports.modules = {

/***/ "(ssr)/../../node_modules/react-intersection-observer/dist/index.mjs":
/*!*********************************************************************!*\
  !*** ../../node_modules/react-intersection-observer/dist/index.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InView: () => (/* binding */ InView),\n/* harmony export */   defaultFallbackInView: () => (/* binding */ defaultFallbackInView),\n/* harmony export */   observe: () => (/* binding */ observe),\n/* harmony export */   useInView: () => (/* binding */ useInView),\n/* harmony export */   useOnInView: () => (/* binding */ useOnInView)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/../../node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ InView,defaultFallbackInView,observe,useInView,useOnInView auto */ var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __publicField = (obj, key, value)=>__defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n// src/InView.tsx\n\n// src/observe.ts\nvar observerMap = /* @__PURE__ */ new Map();\nvar RootIds = /* @__PURE__ */ new WeakMap();\nvar rootId = 0;\nvar unsupportedValue;\nfunction defaultFallbackInView(inView) {\n    unsupportedValue = inView;\n}\nfunction getRootId(root) {\n    if (!root) return \"0\";\n    if (RootIds.has(root)) return RootIds.get(root);\n    rootId += 1;\n    RootIds.set(root, rootId.toString());\n    return RootIds.get(root);\n}\nfunction optionsToId(options) {\n    return Object.keys(options).sort().filter((key)=>options[key] !== void 0).map((key)=>{\n        return `${key}_${key === \"root\" ? getRootId(options.root) : options[key]}`;\n    }).toString();\n}\nfunction createObserver(options) {\n    const id = optionsToId(options);\n    let instance = observerMap.get(id);\n    if (!instance) {\n        const elements = /* @__PURE__ */ new Map();\n        let thresholds;\n        const observer = new IntersectionObserver((entries)=>{\n            entries.forEach((entry)=>{\n                var _a2;\n                const inView = entry.isIntersecting && thresholds.some((threshold)=>entry.intersectionRatio >= threshold);\n                if (options.trackVisibility && typeof entry.isVisible === \"undefined\") {\n                    entry.isVisible = inView;\n                }\n                (_a2 = elements.get(entry.target)) == null ? void 0 : _a2.forEach((callback)=>{\n                    callback(inView, entry);\n                });\n            });\n        }, options);\n        thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [\n            options.threshold || 0\n        ]);\n        instance = {\n            id,\n            observer,\n            elements\n        };\n        observerMap.set(id, instance);\n    }\n    return instance;\n}\nfunction observe(element, callback, options = {}, fallbackInView = unsupportedValue) {\n    if (typeof window.IntersectionObserver === \"undefined\" && fallbackInView !== void 0) {\n        const bounds = element.getBoundingClientRect();\n        callback(fallbackInView, {\n            isIntersecting: fallbackInView,\n            target: element,\n            intersectionRatio: typeof options.threshold === \"number\" ? options.threshold : 0,\n            time: 0,\n            boundingClientRect: bounds,\n            intersectionRect: bounds,\n            rootBounds: bounds\n        });\n        return ()=>{};\n    }\n    const { id, observer, elements } = createObserver(options);\n    const callbacks = elements.get(element) || [];\n    if (!elements.has(element)) {\n        elements.set(element, callbacks);\n    }\n    callbacks.push(callback);\n    observer.observe(element);\n    return function unobserve() {\n        callbacks.splice(callbacks.indexOf(callback), 1);\n        if (callbacks.length === 0) {\n            elements.delete(element);\n            observer.unobserve(element);\n        }\n        if (elements.size === 0) {\n            observer.disconnect();\n            observerMap.delete(id);\n        }\n    };\n}\n// src/InView.tsx\nfunction isPlainChildren(props) {\n    return typeof props.children !== \"function\";\n}\nvar InView = class extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        __publicField(this, \"node\", null);\n        __publicField(this, \"_unobserveCb\", null);\n        __publicField(this, \"lastInView\");\n        __publicField(this, \"handleNode\", (node)=>{\n            if (this.node) {\n                this.unobserve();\n                if (!node && !this.props.triggerOnce && !this.props.skip) {\n                    this.setState({\n                        inView: !!this.props.initialInView,\n                        entry: void 0\n                    });\n                    this.lastInView = this.props.initialInView;\n                }\n            }\n            this.node = node ? node : null;\n            this.observeNode();\n        });\n        __publicField(this, \"handleChange\", (inView, entry)=>{\n            const previousInView = this.lastInView;\n            this.lastInView = inView;\n            if (previousInView === void 0 && !inView) {\n                return;\n            }\n            if (inView && this.props.triggerOnce) {\n                this.unobserve();\n            }\n            if (!isPlainChildren(this.props)) {\n                this.setState({\n                    inView,\n                    entry\n                });\n            }\n            if (this.props.onChange) {\n                this.props.onChange(inView, entry);\n            }\n        });\n        this.state = {\n            inView: !!props.initialInView,\n            entry: void 0\n        };\n        this.lastInView = props.initialInView;\n    }\n    componentDidMount() {\n        this.unobserve();\n        this.observeNode();\n    }\n    componentDidUpdate(prevProps) {\n        if (prevProps.rootMargin !== this.props.rootMargin || prevProps.root !== this.props.root || prevProps.threshold !== this.props.threshold || prevProps.skip !== this.props.skip || prevProps.trackVisibility !== this.props.trackVisibility || prevProps.delay !== this.props.delay) {\n            this.unobserve();\n            this.observeNode();\n        }\n    }\n    componentWillUnmount() {\n        this.unobserve();\n    }\n    observeNode() {\n        if (!this.node || this.props.skip) return;\n        const { threshold, root, rootMargin, trackVisibility, delay, fallbackInView } = this.props;\n        if (this.lastInView === void 0) {\n            this.lastInView = this.props.initialInView;\n        }\n        this._unobserveCb = observe(this.node, this.handleChange, {\n            threshold,\n            root,\n            rootMargin,\n            // @ts-expect-error\n            trackVisibility,\n            delay\n        }, fallbackInView);\n    }\n    unobserve() {\n        if (this._unobserveCb) {\n            this._unobserveCb();\n            this._unobserveCb = null;\n        }\n    }\n    render() {\n        const { children } = this.props;\n        if (typeof children === \"function\") {\n            const { inView, entry } = this.state;\n            return children({\n                inView,\n                entry,\n                ref: this.handleNode\n            });\n        }\n        const { as, triggerOnce, threshold, root, rootMargin, onChange, skip, trackVisibility, delay, initialInView, fallbackInView, ...props } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(as || \"div\", {\n            ref: this.handleNode,\n            ...props\n        }, children);\n    }\n};\n// src/useInView.tsx\n\nfunction useInView({ threshold, delay, trackVisibility, rootMargin, root, triggerOnce, skip, initialInView, fallbackInView, onChange } = {}) {\n    var _a2;\n    const [ref, setRef] = react__WEBPACK_IMPORTED_MODULE_0__.useState(null);\n    const callback = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onChange);\n    const lastInViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(initialInView);\n    const [state, setState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        inView: !!initialInView,\n        entry: void 0\n    });\n    callback.current = onChange;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (lastInViewRef.current === void 0) {\n            lastInViewRef.current = initialInView;\n        }\n        if (skip || !ref) return;\n        let unobserve;\n        unobserve = observe(ref, (inView, entry)=>{\n            const previousInView = lastInViewRef.current;\n            lastInViewRef.current = inView;\n            if (previousInView === void 0 && !inView) {\n                return;\n            }\n            setState({\n                inView,\n                entry\n            });\n            if (callback.current) callback.current(inView, entry);\n            if (entry.isIntersecting && triggerOnce && unobserve) {\n                unobserve();\n                unobserve = void 0;\n            }\n        }, {\n            root,\n            rootMargin,\n            threshold,\n            // @ts-expect-error\n            trackVisibility,\n            delay\n        }, fallbackInView);\n        return ()=>{\n            if (unobserve) {\n                unobserve();\n            }\n        };\n    }, // We break the rule here, because we aren't including the actual `threshold` variable\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        // If the threshold is an array, convert it to a string, so it won't change between renders.\n        Array.isArray(threshold) ? threshold.toString() : threshold,\n        ref,\n        root,\n        rootMargin,\n        triggerOnce,\n        skip,\n        trackVisibility,\n        fallbackInView,\n        delay\n    ]);\n    const entryTarget = (_a2 = state.entry) == null ? void 0 : _a2.target;\n    const previousEntryTarget = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    if (!ref && entryTarget && !triggerOnce && !skip && previousEntryTarget.current !== entryTarget) {\n        previousEntryTarget.current = entryTarget;\n        setState({\n            inView: !!initialInView,\n            entry: void 0\n        });\n        lastInViewRef.current = initialInView;\n    }\n    const result = [\n        setRef,\n        state.inView,\n        state.entry\n    ];\n    result.ref = result[0];\n    result.inView = result[1];\n    result.entry = result[2];\n    return result;\n}\n// src/useOnInView.tsx\n\nvar _a, _b;\nvar useSyncEffect = (_b = (_a = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect) != null ? _a : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect) != null ? _b : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nvar useOnInView = (onIntersectionChange, { threshold, root, rootMargin, trackVisibility, delay, triggerOnce, skip } = {})=>{\n    const onIntersectionChangeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(onIntersectionChange);\n    const observedElementRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const observerCleanupRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    const lastInViewRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(void 0);\n    useSyncEffect(()=>{\n        onIntersectionChangeRef.current = onIntersectionChange;\n    }, [\n        onIntersectionChange\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((element)=>{\n        const cleanupExisting = ()=>{\n            if (observerCleanupRef.current) {\n                const cleanup = observerCleanupRef.current;\n                observerCleanupRef.current = void 0;\n                cleanup();\n            }\n        };\n        if (element === observedElementRef.current) {\n            return observerCleanupRef.current;\n        }\n        if (!element || skip) {\n            cleanupExisting();\n            observedElementRef.current = null;\n            lastInViewRef.current = void 0;\n            return;\n        }\n        cleanupExisting();\n        observedElementRef.current = element;\n        let destroyed = false;\n        const destroyObserver = observe(element, (inView, entry)=>{\n            const previousInView = lastInViewRef.current;\n            lastInViewRef.current = inView;\n            if (previousInView === void 0 && !inView) {\n                return;\n            }\n            onIntersectionChangeRef.current(inView, entry);\n            if (triggerOnce && inView) {\n                stopObserving();\n            }\n        }, {\n            threshold,\n            root,\n            rootMargin,\n            trackVisibility,\n            delay\n        });\n        function stopObserving() {\n            if (destroyed) return;\n            destroyed = true;\n            destroyObserver();\n            observedElementRef.current = null;\n            observerCleanupRef.current = void 0;\n            lastInViewRef.current = void 0;\n        }\n        observerCleanupRef.current = stopObserving;\n        return observerCleanupRef.current;\n    }, [\n        Array.isArray(threshold) ? threshold.toString() : threshold,\n        root,\n        rootMargin,\n        trackVisibility,\n        delay,\n        triggerOnce,\n        skip\n    ]);\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUI7O0FDRXZCLElBQU1DLGNBQWMsb0JBQUlDO0FBU3hCLElBQU1DLFVBQStDLG9CQUFJQztBQUN6RCxJQUFJQyxTQUFTO0FBRWIsSUFBSUM7QUFRRyxTQUFTQyxzQkFBc0JDLE1BQUE7SUFDcENGLG1CQUFtQkU7QUFDckI7QUFNQSxTQUFTQyxVQUFVQyxJQUFBO0lBQ2pCLElBQUksQ0FBQ0EsTUFBTSxPQUFPO0lBQ2xCLElBQUlQLFFBQVFRLEdBQUEsQ0FBSUQsT0FBTyxPQUFPUCxRQUFRUyxHQUFBLENBQUlGO0lBQzFDTCxVQUFVO0lBQ1ZGLFFBQVFVLEdBQUEsQ0FBSUgsTUFBTUwsT0FBT1MsUUFBQTtJQUN6QixPQUFPWCxRQUFRUyxHQUFBLENBQUlGO0FBQ3JCO0FBT08sU0FBU0ssWUFBWUMsT0FBQTtJQUMxQixPQUFPQyxPQUFPQyxJQUFBLENBQUtGLFNBQ2hCRyxJQUFBLEdBQ0FDLE1BQUEsQ0FDQyxDQUFDQyxNQUFRTCxPQUFBLENBQVFLLElBQXFDLEtBQU0sUUFFN0RDLEdBQUEsQ0FBSSxDQUFDRDtRQUNKLE9BQU8sR0FBR0EsSUFBRyxHQUNYQSxRQUFRLFNBQ0paLFVBQVVPLFFBQVFOLElBQUksSUFDdEJNLE9BQUEsQ0FBUUssSUFDZDtJQUNGLEdBQ0NQLFFBQUE7QUFDTDtBQUVBLFNBQVNTLGVBQWVQLE9BQUE7SUFFdEIsTUFBTVEsS0FBS1QsWUFBWUM7SUFDdkIsSUFBSVMsV0FBV3hCLFlBQVlXLEdBQUEsQ0FBSVk7SUFFL0IsSUFBSSxDQUFDQyxVQUFVO1FBRWIsTUFBTUMsV0FBVyxvQkFBSXhCO1FBQ3JCLElBQUl5QjtRQUVKLE1BQU1DLFdBQVcsSUFBSUMscUJBQXFCLENBQUNDO1lBQ3pDQSxRQUFRQyxPQUFBLENBQVEsQ0FBQ0M7Z0JBdEV2QixJQUFBQztnQkF5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d0JaLE9BQUEsQ0FDdEIzRixRQUNBd0I7WUFFRixJQUFJdUMsZUFBZS9ELFFBQVE7Z0JBQ3pCK0c7WUFDRjtRQUNGLEdBQ0E7WUFDRW5GO1lBQ0ExQjtZQUNBeUU7WUFDQTdDO1lBQ0E4QztRQUNGO1FBR0YsU0FBU21DO1lBR1AsSUFBSUYsV0FBVztZQUNmQSxZQUFZO1lBQ1pDO1lBQ0FOLG1CQUFtQmIsT0FBQSxHQUFVO1lBQzdCYyxtQkFBbUJkLE9BQUEsR0FBVTtZQUM3QkQsY0FBY0MsT0FBQSxHQUFVO1FBQzFCO1FBRUFjLG1CQUFtQmQsT0FBQSxHQUFVb0I7UUFFN0IsT0FBT04sbUJBQW1CZCxPQUFBO0lBQzVCLEdBQ0E7UUFDRXpELE1BQU1DLE9BQUEsQ0FBUVAsYUFBYUEsVUFBVXRCLFFBQUEsS0FBYXNCO1FBQ2xEMUI7UUFDQXlFO1FBQ0E3QztRQUNBOEM7UUFDQWI7UUFDQUM7S0FDRjtBQUVKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQHRiL3dlYi8uLi9zcmMvSW5WaWV3LnRzeD9hYmI3Iiwid2VicGFjazovL0B0Yi93ZWIvLi4vc3JjL29ic2VydmUudHM/MWYwMiIsIndlYnBhY2s6Ly9AdGIvd2ViLy4uL3NyYy91c2VJblZpZXcudHN4PzRjMGYiLCJ3ZWJwYWNrOi8vQHRiL3dlYi8uLi9zcmMvdXNlT25JblZpZXcudHN4P2JhZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IEludGVyc2VjdGlvbk9ic2VydmVyUHJvcHMsIFBsYWluQ2hpbGRyZW5Qcm9wcyB9IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgeyBvYnNlcnZlIH0gZnJvbSBcIi4vb2JzZXJ2ZVwiO1xuXG50eXBlIFN0YXRlID0ge1xuICBpblZpZXc6IGJvb2xlYW47XG4gIGVudHJ5PzogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeTtcbn07XG5cbmZ1bmN0aW9uIGlzUGxhaW5DaGlsZHJlbihcbiAgcHJvcHM6IEludGVyc2VjdGlvbk9ic2VydmVyUHJvcHMgfCBQbGFpbkNoaWxkcmVuUHJvcHMsXG4pOiBwcm9wcyBpcyBQbGFpbkNoaWxkcmVuUHJvcHMge1xuICByZXR1cm4gdHlwZW9mIHByb3BzLmNoaWxkcmVuICE9PSBcImZ1bmN0aW9uXCI7XG59XG5cbi8qKlxuICMjIFJlbmRlciBwcm9wc1xuXG4gVG8gdXNlIHRoZSBgPEluVmlldz5gIGNvbXBvbmVudCwgeW91IHBhc3MgaXQgYSBmdW5jdGlvbi4gSXQgd2lsbCBiZSBjYWxsZWRcbiB3aGVuZXZlciB0aGUgc3RhdGUgY2hhbmdlcywgd2l0aCB0aGUgbmV3IHZhbHVlIG9mIGBpblZpZXdgLiBJbiBhZGRpdGlvbiB0byB0aGVcbiBgaW5WaWV3YCBwcm9wLCBjaGlsZHJlbiBhbHNvIHJlY2VpdmUgYSBgcmVmYCB0aGF0IHNob3VsZCBiZSBzZXQgb24gdGhlXG4gY29udGFpbmluZyBET00gZWxlbWVudC4gVGhpcyBpcyB0aGUgZWxlbWVudCB0aGF0IHRoZSBJbnRlcnNlY3Rpb25PYnNlcnZlciB3aWxsXG4gbW9uaXRvci5cblxuIElmIHlvdSBuZWVkIGl0LCB5b3UgY2FuIGFsc28gYWNjZXNzIHRoZVxuIFtgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KVxuIG9uIGBlbnRyeWAsIGdpdmluZyB5b3UgYWNjZXNzIHRvIGFsbCB0aGUgZGV0YWlscyBhYm91dCB0aGUgY3VycmVudCBpbnRlcnNlY3Rpb25cbiBzdGF0ZS5cblxuIGBgYGpzeFxuIGltcG9ydCB7IEluVmlldyB9IGZyb20gJ3JlYWN0LWludGVyc2VjdGlvbi1vYnNlcnZlcic7XG5cbiBjb25zdCBDb21wb25lbnQgPSAoKSA9PiAoXG4gPEluVmlldz5cbiB7KHsgaW5WaWV3LCByZWYsIGVudHJ5IH0pID0+IChcbiAgICAgIDxkaXYgcmVmPXtyZWZ9PlxuICAgICAgICA8aDI+e2BIZWFkZXIgaW5zaWRlIHZpZXdwb3J0ICR7aW5WaWV3fS5gfTwvaDI+XG4gICAgICA8L2Rpdj5cbiAgICApfVxuIDwvSW5WaWV3PlxuICk7XG5cbiBleHBvcnQgZGVmYXVsdCBDb21wb25lbnQ7XG4gYGBgXG5cbiAjIyBQbGFpbiBjaGlsZHJlblxuXG4gWW91IGNhbiBwYXNzIGFueSBlbGVtZW50IHRvIHRoZSBgPEluVmlldyAvPmAsIGFuZCBpdCB3aWxsIGhhbmRsZSBjcmVhdGluZyB0aGVcbiB3cmFwcGluZyBET00gZWxlbWVudC4gQWRkIGEgaGFuZGxlciB0byB0aGUgYG9uQ2hhbmdlYCBtZXRob2QsIGFuZCBjb250cm9sIHRoZVxuIHN0YXRlIGluIHlvdXIgb3duIGNvbXBvbmVudC4gQW55IGV4dHJhIHByb3BzIHlvdSBhZGQgdG8gYDxJblZpZXc+YCB3aWxsIGJlXG4gcGFzc2VkIHRvIHRoZSBIVE1MIGVsZW1lbnQsIGFsbG93aW5nIHlvdSBzZXQgdGhlIGBjbGFzc05hbWVgLCBgc3R5bGVgLCBldGMuXG5cbiBgYGBqc3hcbiBpbXBvcnQgeyBJblZpZXcgfSBmcm9tICdyZWFjdC1pbnRlcnNlY3Rpb24tb2JzZXJ2ZXInO1xuXG4gY29uc3QgQ29tcG9uZW50ID0gKCkgPT4gKFxuIDxJblZpZXcgYXM9XCJkaXZcIiBvbkNoYW5nZT17KGluVmlldywgZW50cnkpID0+IGNvbnNvbGUubG9nKCdJbnZpZXc6JywgaW5WaWV3KX0+XG4gPGgyPlBsYWluIGNoaWxkcmVuIGFyZSBhbHdheXMgcmVuZGVyZWQuIFVzZSBvbkNoYW5nZSB0byBtb25pdG9yIHN0YXRlLjwvaDI+XG4gPC9JblZpZXc+XG4gKTtcblxuIGV4cG9ydCBkZWZhdWx0IENvbXBvbmVudDtcbiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEluVmlldyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudDxcbiAgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJQcm9wcyB8IFBsYWluQ2hpbGRyZW5Qcm9wcyxcbiAgU3RhdGVcbj4ge1xuICBub2RlOiBFbGVtZW50IHwgbnVsbCA9IG51bGw7XG4gIF91bm9ic2VydmVDYjogKCgpID0+IHZvaWQpIHwgbnVsbCA9IG51bGw7XG4gIGxhc3RJblZpZXc6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IocHJvcHM6IEludGVyc2VjdGlvbk9ic2VydmVyUHJvcHMgfCBQbGFpbkNoaWxkcmVuUHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGluVmlldzogISFwcm9wcy5pbml0aWFsSW5WaWV3LFxuICAgICAgZW50cnk6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIHRoaXMubGFzdEluVmlldyA9IHByb3BzLmluaXRpYWxJblZpZXc7XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVub2JzZXJ2ZSgpO1xuICAgIHRoaXMub2JzZXJ2ZU5vZGUoKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHM6IEludGVyc2VjdGlvbk9ic2VydmVyUHJvcHMpIHtcbiAgICAvLyBJZiBhIEludGVyc2VjdGlvbk9ic2VydmVyIG9wdGlvbiBjaGFuZ2VkLCByZWluaXQgdGhlIG9ic2VydmVyXG4gICAgaWYgKFxuICAgICAgcHJldlByb3BzLnJvb3RNYXJnaW4gIT09IHRoaXMucHJvcHMucm9vdE1hcmdpbiB8fFxuICAgICAgcHJldlByb3BzLnJvb3QgIT09IHRoaXMucHJvcHMucm9vdCB8fFxuICAgICAgcHJldlByb3BzLnRocmVzaG9sZCAhPT0gdGhpcy5wcm9wcy50aHJlc2hvbGQgfHxcbiAgICAgIHByZXZQcm9wcy5za2lwICE9PSB0aGlzLnByb3BzLnNraXAgfHxcbiAgICAgIHByZXZQcm9wcy50cmFja1Zpc2liaWxpdHkgIT09IHRoaXMucHJvcHMudHJhY2tWaXNpYmlsaXR5IHx8XG4gICAgICBwcmV2UHJvcHMuZGVsYXkgIT09IHRoaXMucHJvcHMuZGVsYXlcbiAgICApIHtcbiAgICAgIHRoaXMudW5vYnNlcnZlKCk7XG4gICAgICB0aGlzLm9ic2VydmVOb2RlKCk7XG4gICAgfVxuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy51bm9ic2VydmUoKTtcbiAgfVxuXG4gIG9ic2VydmVOb2RlKCkge1xuICAgIGlmICghdGhpcy5ub2RlIHx8IHRoaXMucHJvcHMuc2tpcCkgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIHJvb3QsXG4gICAgICByb290TWFyZ2luLFxuICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgZGVsYXksXG4gICAgICBmYWxsYmFja0luVmlldyxcbiAgICB9ID0gdGhpcy5wcm9wcztcblxuICAgIGlmICh0aGlzLmxhc3RJblZpZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5sYXN0SW5WaWV3ID0gdGhpcy5wcm9wcy5pbml0aWFsSW5WaWV3O1xuICAgIH1cbiAgICB0aGlzLl91bm9ic2VydmVDYiA9IG9ic2VydmUoXG4gICAgICB0aGlzLm5vZGUsXG4gICAgICB0aGlzLmhhbmRsZUNoYW5nZSxcbiAgICAgIHtcbiAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICByb290LFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgICAgZGVsYXksXG4gICAgICB9LFxuICAgICAgZmFsbGJhY2tJblZpZXcsXG4gICAgKTtcbiAgfVxuXG4gIHVub2JzZXJ2ZSgpIHtcbiAgICBpZiAodGhpcy5fdW5vYnNlcnZlQ2IpIHtcbiAgICAgIHRoaXMuX3Vub2JzZXJ2ZUNiKCk7XG4gICAgICB0aGlzLl91bm9ic2VydmVDYiA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlTm9kZSA9IChub2RlPzogRWxlbWVudCB8IG51bGwpID0+IHtcbiAgICBpZiAodGhpcy5ub2RlKSB7XG4gICAgICAvLyBDbGVhciB0aGUgb2xkIG9ic2VydmVyLCBiZWZvcmUgd2Ugc3RhcnQgb2JzZXJ2aW5nIGEgbmV3IGVsZW1lbnRcbiAgICAgIHRoaXMudW5vYnNlcnZlKCk7XG5cbiAgICAgIGlmICghbm9kZSAmJiAhdGhpcy5wcm9wcy50cmlnZ2VyT25jZSAmJiAhdGhpcy5wcm9wcy5za2lwKSB7XG4gICAgICAgIC8vIFJlc2V0IHRoZSBzdGF0ZSBpZiB3ZSBnZXQgYSBuZXcgbm9kZSwgYW5kIHdlIGFyZW4ndCBpZ25vcmluZyB1cGRhdGVzXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBpblZpZXc6ICEhdGhpcy5wcm9wcy5pbml0aWFsSW5WaWV3LCBlbnRyeTogdW5kZWZpbmVkIH0pO1xuICAgICAgICB0aGlzLmxhc3RJblZpZXcgPSB0aGlzLnByb3BzLmluaXRpYWxJblZpZXc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ub2RlID0gbm9kZSA/IG5vZGUgOiBudWxsO1xuICAgIHRoaXMub2JzZXJ2ZU5vZGUoKTtcbiAgfTtcblxuICBoYW5kbGVDaGFuZ2UgPSAoaW5WaWV3OiBib29sZWFuLCBlbnRyeTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSkgPT4ge1xuICAgIGNvbnN0IHByZXZpb3VzSW5WaWV3ID0gdGhpcy5sYXN0SW5WaWV3O1xuICAgIHRoaXMubGFzdEluVmlldyA9IGluVmlldztcblxuICAgIC8vIElnbm9yZSB0aGUgdmVyeSBmaXJzdCBgZmFsc2VgIG5vdGlmaWNhdGlvbiBzbyBjb25zdW1lcnMgb25seSBoZWFyIGFib3V0IGFjdHVhbCBzdGF0ZSBjaGFuZ2VzLlxuICAgIGlmIChwcmV2aW91c0luVmlldyA9PT0gdW5kZWZpbmVkICYmICFpblZpZXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaW5WaWV3ICYmIHRoaXMucHJvcHMudHJpZ2dlck9uY2UpIHtcbiAgICAgIC8vIElmIGB0cmlnZ2VyT25jZWAgaXMgdHJ1ZSwgd2Ugc2hvdWxkIHN0b3Agb2JzZXJ2aW5nIHRoZSBlbGVtZW50LlxuICAgICAgdGhpcy51bm9ic2VydmUoKTtcbiAgICB9XG4gICAgaWYgKCFpc1BsYWluQ2hpbGRyZW4odGhpcy5wcm9wcykpIHtcbiAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IFN0YXRlLCBzbyB3ZSBjYW4gcGFzcyBpdCB0byB0aGUgY2hpbGRyZW4gaW4gdGhlIG5leHQgcmVuZGVyIHVwZGF0ZVxuICAgICAgLy8gVGhlcmUncyBubyByZWFzb24gdG8gdXBkYXRlIHRoZSBzdGF0ZSBmb3IgcGxhaW4gY2hpbGRyZW4sIHNpbmNlIGl0J3Mgbm90IHVzZWQgaW4gdGhlIHJlbmRlcmluZy5cbiAgICAgIHRoaXMuc2V0U3RhdGUoeyBpblZpZXcsIGVudHJ5IH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgaXMgYWN0aXZlbHkgbGlzdGVuaW5nIGZvciBvbkNoYW5nZSwgYWx3YXlzIHRyaWdnZXIgaXRcbiAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UoaW5WaWV3LCBlbnRyeSk7XG4gICAgfVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzO1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3QgeyBpblZpZXcsIGVudHJ5IH0gPSB0aGlzLnN0YXRlO1xuICAgICAgcmV0dXJuIGNoaWxkcmVuKHsgaW5WaWV3LCBlbnRyeSwgcmVmOiB0aGlzLmhhbmRsZU5vZGUgfSk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgYXMsXG4gICAgICB0cmlnZ2VyT25jZSxcbiAgICAgIHRocmVzaG9sZCxcbiAgICAgIHJvb3QsXG4gICAgICByb290TWFyZ2luLFxuICAgICAgb25DaGFuZ2UsXG4gICAgICBza2lwLFxuICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgZGVsYXksXG4gICAgICBpbml0aWFsSW5WaWV3LFxuICAgICAgZmFsbGJhY2tJblZpZXcsXG4gICAgICAuLi5wcm9wc1xuICAgIH0gPSB0aGlzLnByb3BzIGFzIFBsYWluQ2hpbGRyZW5Qcm9wcztcblxuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgYXMgfHwgXCJkaXZcIixcbiAgICAgIHsgcmVmOiB0aGlzLmhhbmRsZU5vZGUsIC4uLnByb3BzIH0sXG4gICAgICBjaGlsZHJlbixcbiAgICApO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSB7IE9ic2VydmVySW5zdGFuY2VDYWxsYmFjayB9IGZyb20gXCIuL2luZGV4XCI7XG5cbmNvbnN0IG9ic2VydmVyTWFwID0gbmV3IE1hcDxcbiAgc3RyaW5nLFxuICB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBvYnNlcnZlcjogSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7XG4gICAgZWxlbWVudHM6IE1hcDxFbGVtZW50LCBBcnJheTxPYnNlcnZlckluc3RhbmNlQ2FsbGJhY2s+PjtcbiAgfVxuPigpO1xuXG5jb25zdCBSb290SWRzOiBXZWFrTWFwPEVsZW1lbnQgfCBEb2N1bWVudCwgc3RyaW5nPiA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgcm9vdElkID0gMDtcblxubGV0IHVuc3VwcG9ydGVkVmFsdWU6IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG5cbi8qKlxuICogV2hhdCBzaG91bGQgYmUgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaWYgdGhlIEludGVyc2VjdGlvbk9ic2VydmVyIGlzIHVuc3VwcG9ydGVkP1xuICogSWRlYWxseSB0aGUgcG9seWZpbGwgaGFzIGJlZW4gbG9hZGVkLCB5b3UgY2FuIGhhdmUgdGhlIGZvbGxvd2luZyBoYXBwZW46XG4gKiAtIGB1bmRlZmluZWRgOiBUaHJvdyBhbiBlcnJvclxuICogLSBgdHJ1ZWAgb3IgYGZhbHNlYDogU2V0IHRoZSBgaW5WaWV3YCB2YWx1ZSB0byB0aGlzIHJlZ2FyZGxlc3Mgb2YgaW50ZXJzZWN0aW9uIHN0YXRlXG4gKiAqKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0RmFsbGJhY2tJblZpZXcoaW5WaWV3OiBib29sZWFuIHwgdW5kZWZpbmVkKSB7XG4gIHVuc3VwcG9ydGVkVmFsdWUgPSBpblZpZXc7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHRoZSByb290IGVsZW1lbnRcbiAqIEBwYXJhbSByb290XG4gKi9cbmZ1bmN0aW9uIGdldFJvb3RJZChyb290OiBJbnRlcnNlY3Rpb25PYnNlcnZlckluaXRbXCJyb290XCJdKSB7XG4gIGlmICghcm9vdCkgcmV0dXJuIFwiMFwiO1xuICBpZiAoUm9vdElkcy5oYXMocm9vdCkpIHJldHVybiBSb290SWRzLmdldChyb290KTtcbiAgcm9vdElkICs9IDE7XG4gIFJvb3RJZHMuc2V0KHJvb3QsIHJvb3RJZC50b1N0cmluZygpKTtcbiAgcmV0dXJuIFJvb3RJZHMuZ2V0KHJvb3QpO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIG9wdGlvbnMgdG8gYSBzdHJpbmcgSWQsIGJhc2VkIG9uIHRoZSB2YWx1ZXMuXG4gKiBFbnN1cmVzIHdlIGNhbiByZXVzZSB0aGUgc2FtZSBvYnNlcnZlciB3aGVuIG9ic2VydmluZyBlbGVtZW50cyB3aXRoIHRoZSBzYW1lIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uc1RvSWQob3B0aW9uczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0KSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvcHRpb25zKVxuICAgIC5zb3J0KClcbiAgICAuZmlsdGVyKFxuICAgICAgKGtleSkgPT4gb3B0aW9uc1trZXkgYXMga2V5b2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0XSAhPT0gdW5kZWZpbmVkLFxuICAgIClcbiAgICAubWFwKChrZXkpID0+IHtcbiAgICAgIHJldHVybiBgJHtrZXl9XyR7XG4gICAgICAgIGtleSA9PT0gXCJyb290XCJcbiAgICAgICAgICA/IGdldFJvb3RJZChvcHRpb25zLnJvb3QpXG4gICAgICAgICAgOiBvcHRpb25zW2tleSBhcyBrZXlvZiBJbnRlcnNlY3Rpb25PYnNlcnZlckluaXRdXG4gICAgICB9YDtcbiAgICB9KVxuICAgIC50b1N0cmluZygpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlcihvcHRpb25zOiBJbnRlcnNlY3Rpb25PYnNlcnZlckluaXQpIHtcbiAgLy8gQ3JlYXRlIGEgdW5pcXVlIElEIGZvciB0aGlzIG9ic2VydmVyIGluc3RhbmNlLCBiYXNlZCBvbiB0aGUgcm9vdCwgcm9vdCBtYXJnaW4gYW5kIHRocmVzaG9sZC5cbiAgY29uc3QgaWQgPSBvcHRpb25zVG9JZChvcHRpb25zKTtcbiAgbGV0IGluc3RhbmNlID0gb2JzZXJ2ZXJNYXAuZ2V0KGlkKTtcblxuICBpZiAoIWluc3RhbmNlKSB7XG4gICAgLy8gQ3JlYXRlIGEgbWFwIG9mIGVsZW1lbnRzIHRoaXMgb2JzZXJ2ZXIgaXMgZ29pbmcgdG8gb2JzZXJ2ZS4gRWFjaCBlbGVtZW50IGhhcyBhIGxpc3Qgb2YgY2FsbGJhY2tzIHRoYXQgc2hvdWxkIGJlIHRyaWdnZXJlZCwgb25jZSBpdCBjb21lcyBpbnRvIHZpZXcuXG4gICAgY29uc3QgZWxlbWVudHMgPSBuZXcgTWFwPEVsZW1lbnQsIEFycmF5PE9ic2VydmVySW5zdGFuY2VDYWxsYmFjaz4+KCk7XG4gICAgbGV0IHRocmVzaG9sZHM6IG51bWJlcltdIHwgcmVhZG9ubHkgbnVtYmVyW107XG5cbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAvLyBXaGlsZSBpdCB3b3VsZCBiZSBuaWNlIGlmIHlvdSBjb3VsZCBqdXN0IGxvb2sgYXQgaXNJbnRlcnNlY3RpbmcgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjb21wb25lbnQgaXMgaW5zaWRlIHRoZSB2aWV3cG9ydCwgYnJvd3NlcnMgY2FuJ3QgYWdyZWUgb24gaG93IHRvIHVzZSBpdC5cbiAgICAgICAgLy8gLUZpcmVmb3ggaWdub3JlcyBgdGhyZXNob2xkYCB3aGVuIGNvbnNpZGVyaW5nIGBpc0ludGVyc2VjdGluZ2AsIHNvIGl0IHdpbGwgbmV2ZXIgYmUgZmFsc2UgYWdhaW4gaWYgYHRocmVzaG9sZGAgaXMgPiAwXG4gICAgICAgIGNvbnN0IGluVmlldyA9XG4gICAgICAgICAgZW50cnkuaXNJbnRlcnNlY3RpbmcgJiZcbiAgICAgICAgICB0aHJlc2hvbGRzLnNvbWUoKHRocmVzaG9sZCkgPT4gZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gPj0gdGhyZXNob2xkKTtcblxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHN1cHBvcnQgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgdjJcbiAgICAgICAgaWYgKG9wdGlvbnMudHJhY2tWaXNpYmlsaXR5ICYmIHR5cGVvZiBlbnRyeS5pc1Zpc2libGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAvLyBUaGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnQgSW50ZXJzZWN0aW9uIE9ic2VydmVyIHYyLCBmYWxsaW5nIGJhY2sgdG8gdjEgYmVoYXZpb3IuXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgIGVudHJ5LmlzVmlzaWJsZSA9IGluVmlldztcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzLmdldChlbnRyeS50YXJnZXQpPy5mb3JFYWNoKChjYWxsYmFjaykgPT4ge1xuICAgICAgICAgIGNhbGxiYWNrKGluVmlldywgZW50cnkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgYSB2YWxpZCB0aHJlc2hvbGRzIGFycmF5LiBJZiBub3QsIHVzZSB0aGUgdGhyZXNob2xkIGZyb20gdGhlIG9wdGlvbnNcbiAgICB0aHJlc2hvbGRzID1cbiAgICAgIG9ic2VydmVyLnRocmVzaG9sZHMgfHxcbiAgICAgIChBcnJheS5pc0FycmF5KG9wdGlvbnMudGhyZXNob2xkKVxuICAgICAgICA/IG9wdGlvbnMudGhyZXNob2xkXG4gICAgICAgIDogW29wdGlvbnMudGhyZXNob2xkIHx8IDBdKTtcblxuICAgIGluc3RhbmNlID0ge1xuICAgICAgaWQsXG4gICAgICBvYnNlcnZlcixcbiAgICAgIGVsZW1lbnRzLFxuICAgIH07XG5cbiAgICBvYnNlcnZlck1hcC5zZXQoaWQsIGluc3RhbmNlKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0gZWxlbWVudCAtIERPTSBFbGVtZW50IHRvIG9ic2VydmVcbiAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIHRyaWdnZXIgd2hlbiBpbnRlcnNlY3Rpb24gc3RhdHVzIGNoYW5nZXNcbiAqIEBwYXJhbSBvcHRpb25zIC0gSW50ZXJzZWN0aW9uIE9ic2VydmVyIG9wdGlvbnNcbiAqIEBwYXJhbSBmYWxsYmFja0luVmlldyAtIEZhbGxiYWNrIGluVmlldyB2YWx1ZS5cbiAqIEByZXR1cm4gRnVuY3Rpb24gLSBDbGVhbnVwIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIHRyaWdnZXJlZCB0byB1bnJlZ2lzdGVyIHRoZSBvYnNlcnZlclxuICovXG5leHBvcnQgZnVuY3Rpb24gb2JzZXJ2ZShcbiAgZWxlbWVudDogRWxlbWVudCxcbiAgY2FsbGJhY2s6IE9ic2VydmVySW5zdGFuY2VDYWxsYmFjayxcbiAgb3B0aW9uczogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJJbml0ID0ge30sXG4gIGZhbGxiYWNrSW5WaWV3ID0gdW5zdXBwb3J0ZWRWYWx1ZSxcbikge1xuICBpZiAoXG4gICAgdHlwZW9mIHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIGZhbGxiYWNrSW5WaWV3ICE9PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgY29uc3QgYm91bmRzID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjYWxsYmFjayhmYWxsYmFja0luVmlldywge1xuICAgICAgaXNJbnRlcnNlY3Rpbmc6IGZhbGxiYWNrSW5WaWV3LFxuICAgICAgdGFyZ2V0OiBlbGVtZW50LFxuICAgICAgaW50ZXJzZWN0aW9uUmF0aW86XG4gICAgICAgIHR5cGVvZiBvcHRpb25zLnRocmVzaG9sZCA9PT0gXCJudW1iZXJcIiA/IG9wdGlvbnMudGhyZXNob2xkIDogMCxcbiAgICAgIHRpbWU6IDAsXG4gICAgICBib3VuZGluZ0NsaWVudFJlY3Q6IGJvdW5kcyxcbiAgICAgIGludGVyc2VjdGlvblJlY3Q6IGJvdW5kcyxcbiAgICAgIHJvb3RCb3VuZHM6IGJvdW5kcyxcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gTm90aGluZyB0byBjbGVhbnVwXG4gICAgfTtcbiAgfVxuICAvLyBBbiBvYnNlcnZlciB3aXRoIHRoZSBzYW1lIG9wdGlvbnMgY2FuIGJlIHJldXNlZCwgc28gbGV0cyB1c2UgdGhpcyBmYWN0XG4gIGNvbnN0IHsgaWQsIG9ic2VydmVyLCBlbGVtZW50cyB9ID0gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucyk7XG5cbiAgLy8gUmVnaXN0ZXIgdGhlIGNhbGxiYWNrIGxpc3RlbmVyIGZvciB0aGlzIGVsZW1lbnRcbiAgY29uc3QgY2FsbGJhY2tzID0gZWxlbWVudHMuZ2V0KGVsZW1lbnQpIHx8IFtdO1xuICBpZiAoIWVsZW1lbnRzLmhhcyhlbGVtZW50KSkge1xuICAgIGVsZW1lbnRzLnNldChlbGVtZW50LCBjYWxsYmFja3MpO1xuICB9XG5cbiAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuXG4gIHJldHVybiBmdW5jdGlvbiB1bm9ic2VydmUoKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIHRoZSBjYWxsYmFjayBsaXN0XG4gICAgY2FsbGJhY2tzLnNwbGljZShjYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayksIDEpO1xuXG4gICAgaWYgKGNhbGxiYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vIG1vcmUgY2FsbGJhY2sgZXhpc3RzIGZvciBlbGVtZW50LCBzbyBkZXN0cm95IGl0XG4gICAgICBlbGVtZW50cy5kZWxldGUoZWxlbWVudCk7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgIC8vIE5vIG1vcmUgZWxlbWVudHMgYXJlIGJlaW5nIG9ic2VydmVyIGJ5IHRoaXMgaW5zdGFuY2UsIHNvIGRlc3Ryb3kgaXRcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIG9ic2VydmVyTWFwLmRlbGV0ZShpZCk7XG4gICAgfVxuICB9O1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7IEludGVyc2VjdGlvbk9wdGlvbnMsIEluVmlld0hvb2tSZXNwb25zZSB9IGZyb20gXCIuL2luZGV4XCI7XG5pbXBvcnQgeyBvYnNlcnZlIH0gZnJvbSBcIi4vb2JzZXJ2ZVwiO1xuXG50eXBlIFN0YXRlID0ge1xuICBpblZpZXc6IGJvb2xlYW47XG4gIGVudHJ5PzogSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeTtcbn07XG5cbi8qKlxuICogUmVhY3QgSG9va3MgbWFrZSBpdCBlYXN5IHRvIG1vbml0b3IgdGhlIGBpblZpZXdgIHN0YXRlIG9mIHlvdXIgY29tcG9uZW50cy4gQ2FsbFxuICogdGhlIGB1c2VJblZpZXdgIGhvb2sgd2l0aCB0aGUgKG9wdGlvbmFsKSBbb3B0aW9uc10oI29wdGlvbnMpIHlvdSBuZWVkLiBJdCB3aWxsXG4gKiByZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyBhIGByZWZgLCB0aGUgYGluVmlld2Agc3RhdHVzIGFuZCB0aGUgY3VycmVudFxuICogW2BlbnRyeWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KS5cbiAqIEFzc2lnbiB0aGUgYHJlZmAgdG8gdGhlIERPTSBlbGVtZW50IHlvdSB3YW50IHRvIG1vbml0b3IsIGFuZCB0aGUgaG9vayB3aWxsXG4gKiByZXBvcnQgdGhlIHN0YXR1cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKiBpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuICogaW1wb3J0IHsgdXNlSW5WaWV3IH0gZnJvbSAncmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyJztcbiAqXG4gKiBjb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IHsgcmVmLCBpblZpZXcsIGVudHJ5IH0gPSB1c2VJblZpZXcoe1xuICogICAgICAgdGhyZXNob2xkOiAwLFxuICogICB9KTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdiByZWY9e3JlZn0+XG4gKiAgICAgICA8aDI+e2BIZWFkZXIgaW5zaWRlIHZpZXdwb3J0ICR7aW5WaWV3fS5gfTwvaDI+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9O1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJblZpZXcoe1xuICB0aHJlc2hvbGQsXG4gIGRlbGF5LFxuICB0cmFja1Zpc2liaWxpdHksXG4gIHJvb3RNYXJnaW4sXG4gIHJvb3QsXG4gIHRyaWdnZXJPbmNlLFxuICBza2lwLFxuICBpbml0aWFsSW5WaWV3LFxuICBmYWxsYmFja0luVmlldyxcbiAgb25DaGFuZ2UsXG59OiBJbnRlcnNlY3Rpb25PcHRpb25zID0ge30pOiBJblZpZXdIb29rUmVzcG9uc2Uge1xuICBjb25zdCBbcmVmLCBzZXRSZWZdID0gUmVhY3QudXNlU3RhdGU8RWxlbWVudCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjYWxsYmFjayA9IFJlYWN0LnVzZVJlZjxJbnRlcnNlY3Rpb25PcHRpb25zW1wib25DaGFuZ2VcIl0+KG9uQ2hhbmdlKTtcbiAgY29uc3QgbGFzdEluVmlld1JlZiA9IFJlYWN0LnVzZVJlZjxib29sZWFuIHwgdW5kZWZpbmVkPihpbml0aWFsSW5WaWV3KTtcbiAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZV0gPSBSZWFjdC51c2VTdGF0ZTxTdGF0ZT4oe1xuICAgIGluVmlldzogISFpbml0aWFsSW5WaWV3LFxuICAgIGVudHJ5OiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIC8vIFN0b3JlIHRoZSBvbkNoYW5nZSBjYWxsYmFjayBpbiBhIGByZWZgLCBzbyB3ZSBjYW4gYWNjZXNzIHRoZSBsYXRlc3QgaW5zdGFuY2VcbiAgLy8gaW5zaWRlIHRoZSBgdXNlRWZmZWN0YCwgYnV0IHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlcmVuZGVyLlxuICBjYWxsYmFjay5jdXJyZW50ID0gb25DaGFuZ2U7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogdGhyZXNob2xkIGlzIG5vdCBjb3JyZWN0bHkgZGV0ZWN0ZWQgYXMgYSBkZXBlbmRlbmN5XG4gIFJlYWN0LnVzZUVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICBpZiAobGFzdEluVmlld1JlZi5jdXJyZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbGFzdEluVmlld1JlZi5jdXJyZW50ID0gaW5pdGlhbEluVmlldztcbiAgICAgIH1cbiAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIG5vZGUgcmVmLCBhbmQgdGhhdCB3ZSBzaG91bGRuJ3Qgc2tpcCBvYnNlcnZpbmdcbiAgICAgIGlmIChza2lwIHx8ICFyZWYpIHJldHVybjtcblxuICAgICAgbGV0IHVub2JzZXJ2ZTogKCgpID0+IHZvaWQpIHwgdW5kZWZpbmVkO1xuICAgICAgdW5vYnNlcnZlID0gb2JzZXJ2ZShcbiAgICAgICAgcmVmLFxuICAgICAgICAoaW5WaWV3LCBlbnRyeSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzSW5WaWV3ID0gbGFzdEluVmlld1JlZi5jdXJyZW50O1xuICAgICAgICAgIGxhc3RJblZpZXdSZWYuY3VycmVudCA9IGluVmlldztcblxuICAgICAgICAgIC8vIElnbm9yZSB0aGUgdmVyeSBmaXJzdCBgZmFsc2VgIG5vdGlmaWNhdGlvbiBzbyBjb25zdW1lcnMgb25seSBoZWFyIGFib3V0IGFjdHVhbCBzdGF0ZSBjaGFuZ2VzLlxuICAgICAgICAgIGlmIChwcmV2aW91c0luVmlldyA9PT0gdW5kZWZpbmVkICYmICFpblZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRTdGF0ZSh7XG4gICAgICAgICAgICBpblZpZXcsXG4gICAgICAgICAgICBlbnRyeSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2suY3VycmVudCkgY2FsbGJhY2suY3VycmVudChpblZpZXcsIGVudHJ5KTtcblxuICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZyAmJiB0cmlnZ2VyT25jZSAmJiB1bm9ic2VydmUpIHtcbiAgICAgICAgICAgIC8vIElmIGl0IHNob3VsZCBvbmx5IHRyaWdnZXIgb25jZSwgdW5vYnNlcnZlIHRoZSBlbGVtZW50IGFmdGVyIGl0J3MgaW5WaWV3XG4gICAgICAgICAgICB1bm9ic2VydmUoKTtcbiAgICAgICAgICAgIHVub2JzZXJ2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICByb290LFxuICAgICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICAgICAgZGVsYXksXG4gICAgICAgIH0sXG4gICAgICAgIGZhbGxiYWNrSW5WaWV3LFxuICAgICAgKTtcblxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgaWYgKHVub2JzZXJ2ZSkge1xuICAgICAgICAgIHVub2JzZXJ2ZSgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gV2UgYnJlYWsgdGhlIHJ1bGUgaGVyZSwgYmVjYXVzZSB3ZSBhcmVuJ3QgaW5jbHVkaW5nIHRoZSBhY3R1YWwgYHRocmVzaG9sZGAgdmFyaWFibGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgLy8gSWYgdGhlIHRocmVzaG9sZCBpcyBhbiBhcnJheSwgY29udmVydCBpdCB0byBhIHN0cmluZywgc28gaXQgd29uJ3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy5cbiAgICAgIEFycmF5LmlzQXJyYXkodGhyZXNob2xkKSA/IHRocmVzaG9sZC50b1N0cmluZygpIDogdGhyZXNob2xkLFxuICAgICAgcmVmLFxuICAgICAgcm9vdCxcbiAgICAgIHJvb3RNYXJnaW4sXG4gICAgICB0cmlnZ2VyT25jZSxcbiAgICAgIHNraXAsXG4gICAgICB0cmFja1Zpc2liaWxpdHksXG4gICAgICBmYWxsYmFja0luVmlldyxcbiAgICAgIGRlbGF5LFxuICAgIF0sXG4gICk7XG5cbiAgY29uc3QgZW50cnlUYXJnZXQgPSBzdGF0ZS5lbnRyeT8udGFyZ2V0O1xuICBjb25zdCBwcmV2aW91c0VudHJ5VGFyZ2V0ID0gUmVhY3QudXNlUmVmPEVsZW1lbnQgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gIGlmIChcbiAgICAhcmVmICYmXG4gICAgZW50cnlUYXJnZXQgJiZcbiAgICAhdHJpZ2dlck9uY2UgJiZcbiAgICAhc2tpcCAmJlxuICAgIHByZXZpb3VzRW50cnlUYXJnZXQuY3VycmVudCAhPT0gZW50cnlUYXJnZXRcbiAgKSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG5vZGUgcmVmLCB0aGVuIHJlc2V0IHRoZSBzdGF0ZSAodW5sZXNzIHRoZSBob29rIGlzIHNldCB0byBvbmx5IGB0cmlnZ2VyT25jZWAgb3IgYHNraXBgKVxuICAgIC8vIFRoaXMgZW5zdXJlcyB3ZSBjb3JyZWN0bHkgcmVmbGVjdCB0aGUgY3VycmVudCBzdGF0ZSAtIElmIHlvdSBhcmVuJ3Qgb2JzZXJ2aW5nIGFueXRoaW5nLCB0aGVuIG5vdGhpbmcgaXMgaW5WaWV3XG4gICAgcHJldmlvdXNFbnRyeVRhcmdldC5jdXJyZW50ID0gZW50cnlUYXJnZXQ7XG4gICAgc2V0U3RhdGUoe1xuICAgICAgaW5WaWV3OiAhIWluaXRpYWxJblZpZXcsXG4gICAgICBlbnRyeTogdW5kZWZpbmVkLFxuICAgIH0pO1xuICAgIGxhc3RJblZpZXdSZWYuY3VycmVudCA9IGluaXRpYWxJblZpZXc7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBbc2V0UmVmLCBzdGF0ZS5pblZpZXcsIHN0YXRlLmVudHJ5XSBhcyBJblZpZXdIb29rUmVzcG9uc2U7XG5cbiAgLy8gU3VwcG9ydCBvYmplY3QgZGVzdHJ1Y3R1cmluZywgYnkgYWRkaW5nIHRoZSBzcGVjaWZpYyB2YWx1ZXMuXG4gIHJlc3VsdC5yZWYgPSByZXN1bHRbMF07XG4gIHJlc3VsdC5pblZpZXcgPSByZXN1bHRbMV07XG4gIHJlc3VsdC5lbnRyeSA9IHJlc3VsdFsyXTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdHlwZSB7XG4gIEludGVyc2VjdGlvbkNoYW5nZUVmZmVjdCxcbiAgSW50ZXJzZWN0aW9uRWZmZWN0T3B0aW9ucyxcbn0gZnJvbSBcIi4vaW5kZXhcIjtcbmltcG9ydCB7IG9ic2VydmUgfSBmcm9tIFwiLi9vYnNlcnZlXCI7XG5cbmNvbnN0IHVzZVN5bmNFZmZlY3QgPVxuICAoXG4gICAgUmVhY3QgYXMgdHlwZW9mIFJlYWN0ICYge1xuICAgICAgdXNlSW5zZXJ0aW9uRWZmZWN0PzogdHlwZW9mIFJlYWN0LnVzZUVmZmVjdDtcbiAgICB9XG4gICkudXNlSW5zZXJ0aW9uRWZmZWN0ID8/XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCA/P1xuICBSZWFjdC51c2VFZmZlY3Q7XG5cbi8qKlxuICogUmVhY3QgSG9va3MgbWFrZSBpdCBlYXN5IHRvIG1vbml0b3Igd2hlbiBlbGVtZW50cyBjb21lIGludG8gYW5kIGxlYXZlIHZpZXcuIENhbGxcbiAqIHRoZSBgdXNlT25JblZpZXdgIGhvb2sgd2l0aCB5b3VyIGNhbGxiYWNrIGFuZCAob3B0aW9uYWwpIFtvcHRpb25zXSgjb3B0aW9ucykuXG4gKiBJdCB3aWxsIHJldHVybiBhIHJlZiBjYWxsYmFjayB0aGF0IHlvdSBjYW4gYXNzaWduIHRvIHRoZSBET00gZWxlbWVudCB5b3Ugd2FudCB0byBtb25pdG9yLlxuICogV2hlbiB0aGUgZWxlbWVudCBlbnRlcnMgb3IgbGVhdmVzIHRoZSB2aWV3cG9ydCwgeW91ciBjYWxsYmFjayB3aWxsIGJlIHRyaWdnZXJlZC5cbiAqXG4gKiBUaGlzIGhvb2sgdHJpZ2dlcnMgbm8gcmUtcmVuZGVycywgYW5kIGlzIHVzZWZ1bCBmb3IgcGVyZm9ybWFuY2UtY3JpdGljYWwgdXNlLWNhc2VzIG9yXG4gKiB3aGVuIHlvdSBuZWVkIHRvIHRyaWdnZXIgcmVuZGVyIGluZGVwZW5kZW50IHNpZGUgZWZmZWN0cyBsaWtlIHRyYWNraW5nIG9yIGxvZ2dpbmcuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IHVzZU9uSW5WaWV3IH0gZnJvbSAncmVhY3QtaW50ZXJzZWN0aW9uLW9ic2VydmVyJztcbiAqXG4gKiBjb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IGluVmlld1JlZiA9IHVzZU9uSW5WaWV3KChpblZpZXcsIGVudHJ5KSA9PiB7XG4gKiAgICAgaWYgKGluVmlldykge1xuICogICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50IGlzIGluIHZpZXdcIiwgZW50cnkudGFyZ2V0KTtcbiAqICAgICB9IGVsc2Uge1xuICogICAgICAgY29uc29sZS5sb2coXCJFbGVtZW50IGxlZnQgdmlld1wiLCBlbnRyeS50YXJnZXQpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxkaXYgcmVmPXtpblZpZXdSZWZ9PlxuICogICAgICAgPGgyPlRoaXMgZWxlbWVudCBpcyBiZWluZyBtb25pdG9yZWQ8L2gyPlxuICogICAgIDwvZGl2PlxuICogICApO1xuICogfTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgdXNlT25JblZpZXcgPSA8VEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PihcbiAgb25JbnRlcnNlY3Rpb25DaGFuZ2U6IEludGVyc2VjdGlvbkNoYW5nZUVmZmVjdDxURWxlbWVudD4sXG4gIHtcbiAgICB0aHJlc2hvbGQsXG4gICAgcm9vdCxcbiAgICByb290TWFyZ2luLFxuICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICBkZWxheSxcbiAgICB0cmlnZ2VyT25jZSxcbiAgICBza2lwLFxuICB9OiBJbnRlcnNlY3Rpb25FZmZlY3RPcHRpb25zID0ge30sXG4pID0+IHtcbiAgY29uc3Qgb25JbnRlcnNlY3Rpb25DaGFuZ2VSZWYgPSBSZWFjdC51c2VSZWYob25JbnRlcnNlY3Rpb25DaGFuZ2UpO1xuICBjb25zdCBvYnNlcnZlZEVsZW1lbnRSZWYgPSBSZWFjdC51c2VSZWY8VEVsZW1lbnQgfCBudWxsPihudWxsKTtcbiAgY29uc3Qgb2JzZXJ2ZXJDbGVhbnVwUmVmID0gUmVhY3QudXNlUmVmPCgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcbiAgY29uc3QgbGFzdEluVmlld1JlZiA9IFJlYWN0LnVzZVJlZjxib29sZWFuIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG4gIHVzZVN5bmNFZmZlY3QoKCkgPT4ge1xuICAgIG9uSW50ZXJzZWN0aW9uQ2hhbmdlUmVmLmN1cnJlbnQgPSBvbkludGVyc2VjdGlvbkNoYW5nZTtcbiAgfSwgW29uSW50ZXJzZWN0aW9uQ2hhbmdlXSk7XG5cbiAgLy8gYmlvbWUtaWdub3JlIGxpbnQvY29ycmVjdG5lc3MvdXNlRXhoYXVzdGl2ZURlcGVuZGVuY2llczogVGhyZXNob2xkIGFycmF5cyBhcmUgbm9ybWFsaXplZCBpbnNpZGUgdGhlIGNhbGxiYWNrXG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoZWxlbWVudDogVEVsZW1lbnQgfCB1bmRlZmluZWQgfCBudWxsKSA9PiB7XG4gICAgICAvLyBSZWFjdCA8MTkgbmV2ZXIgY2FsbHMgcmVmIGNhbGxiYWNrcyB3aXRoIGBudWxsYCBkdXJpbmcgdW5tb3VudCwgc28gd2VcbiAgICAgIC8vIGVhZ2VybHkgdGVhciBkb3duIGV4aXN0aW5nIG9ic2VydmVycyBtYW51YWxseSB3aGVuZXZlciB0aGUgdGFyZ2V0IGNoYW5nZXMuXG4gICAgICBjb25zdCBjbGVhbnVwRXhpc3RpbmcgPSAoKSA9PiB7XG4gICAgICAgIGlmIChvYnNlcnZlckNsZWFudXBSZWYuY3VycmVudCkge1xuICAgICAgICAgIGNvbnN0IGNsZWFudXAgPSBvYnNlcnZlckNsZWFudXBSZWYuY3VycmVudDtcbiAgICAgICAgICBvYnNlcnZlckNsZWFudXBSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChlbGVtZW50ID09PSBvYnNlcnZlZEVsZW1lbnRSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZXJDbGVhbnVwUmVmLmN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGlmICghZWxlbWVudCB8fCBza2lwKSB7XG4gICAgICAgIGNsZWFudXBFeGlzdGluZygpO1xuICAgICAgICBvYnNlcnZlZEVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIGxhc3RJblZpZXdSZWYuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjbGVhbnVwRXhpc3RpbmcoKTtcblxuICAgICAgb2JzZXJ2ZWRFbGVtZW50UmVmLmN1cnJlbnQgPSBlbGVtZW50O1xuICAgICAgbGV0IGRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICBjb25zdCBkZXN0cm95T2JzZXJ2ZXIgPSBvYnNlcnZlKFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICAoaW5WaWV3LCBlbnRyeSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHByZXZpb3VzSW5WaWV3ID0gbGFzdEluVmlld1JlZi5jdXJyZW50O1xuICAgICAgICAgIGxhc3RJblZpZXdSZWYuY3VycmVudCA9IGluVmlldztcblxuICAgICAgICAgIC8vIElnbm9yZSB0aGUgdmVyeSBmaXJzdCBgZmFsc2VgIG5vdGlmaWNhdGlvbiBzbyBjb25zdW1lcnMgb25seSBoZWFyIGFib3V0IGFjdHVhbCBzdGF0ZSBjaGFuZ2VzLlxuICAgICAgICAgIGlmIChwcmV2aW91c0luVmlldyA9PT0gdW5kZWZpbmVkICYmICFpblZpZXcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvbkludGVyc2VjdGlvbkNoYW5nZVJlZi5jdXJyZW50KFxuICAgICAgICAgICAgaW5WaWV3LFxuICAgICAgICAgICAgZW50cnkgYXMgSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeSAmIHsgdGFyZ2V0OiBURWxlbWVudCB9LFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHRyaWdnZXJPbmNlICYmIGluVmlldykge1xuICAgICAgICAgICAgc3RvcE9ic2VydmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHRocmVzaG9sZCxcbiAgICAgICAgICByb290LFxuICAgICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgICAgdHJhY2tWaXNpYmlsaXR5LFxuICAgICAgICAgIGRlbGF5LFxuICAgICAgICB9IGFzIEludGVyc2VjdGlvbk9ic2VydmVySW5pdCxcbiAgICAgICk7XG5cbiAgICAgIGZ1bmN0aW9uIHN0b3BPYnNlcnZpbmcoKSB7XG4gICAgICAgIC8vIENlbnRyYWxpemVkIHRlYXJkb3duIHNvIGJvdGggbWFudWFsIGRlc3Ryb3lzIGFuZCBSZWFjdCByZWYgdXBkYXRlcyBzaGFyZVxuICAgICAgICAvLyB0aGUgc2FtZSBjbGVhbnVwIHBhdGggKG5lZWRlZCBmb3IgUmVhY3QgdmVyc2lvbnMgdGhhdCBuZXZlciBjYWxsIHRoZSByZWYgd2l0aCBgbnVsbGApLlxuICAgICAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIGRlc3Ryb3lPYnNlcnZlcigpO1xuICAgICAgICBvYnNlcnZlZEVsZW1lbnRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIG9ic2VydmVyQ2xlYW51cFJlZi5jdXJyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW5WaWV3UmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIG9ic2VydmVyQ2xlYW51cFJlZi5jdXJyZW50ID0gc3RvcE9ic2VydmluZztcblxuICAgICAgcmV0dXJuIG9ic2VydmVyQ2xlYW51cFJlZi5jdXJyZW50O1xuICAgIH0sXG4gICAgW1xuICAgICAgQXJyYXkuaXNBcnJheSh0aHJlc2hvbGQpID8gdGhyZXNob2xkLnRvU3RyaW5nKCkgOiB0aHJlc2hvbGQsXG4gICAgICByb290LFxuICAgICAgcm9vdE1hcmdpbixcbiAgICAgIHRyYWNrVmlzaWJpbGl0eSxcbiAgICAgIGRlbGF5LFxuICAgICAgdHJpZ2dlck9uY2UsXG4gICAgICBza2lwLFxuICAgIF0sXG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0Iiwib2JzZXJ2ZXJNYXAiLCJNYXAiLCJSb290SWRzIiwiV2Vha01hcCIsInJvb3RJZCIsInVuc3VwcG9ydGVkVmFsdWUiLCJkZWZhdWx0RmFsbGJhY2tJblZpZXciLCJpblZpZXciLCJnZXRSb290SWQiLCJyb290IiwiaGFzIiwiZ2V0Iiwic2V0IiwidG9TdHJpbmciLCJvcHRpb25zVG9JZCIsIm9wdGlvbnMiLCJPYmplY3QiLCJrZXlzIiwic29ydCIsImZpbHRlciIsImtleSIsIm1hcCIsImNyZWF0ZU9ic2VydmVyIiwiaWQiLCJpbnN0YW5jZSIsImVsZW1lbnRzIiwidGhyZXNob2xkcyIsIm9ic2VydmVyIiwiSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiX2EiLCJpc0ludGVyc2VjdGluZyIsInNvbWUiLCJ0aHJlc2hvbGQiLCJpbnRlcnNlY3Rpb25SYXRpbyIsInRyYWNrVmlzaWJpbGl0eSIsImlzVmlzaWJsZSIsInRhcmdldCIsImNhbGxiYWNrIiwiQXJyYXkiLCJpc0FycmF5Iiwib2JzZXJ2ZSIsImVsZW1lbnQiLCJmYWxsYmFja0luVmlldyIsIndpbmRvdyIsImJvdW5kcyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInRpbWUiLCJib3VuZGluZ0NsaWVudFJlY3QiLCJpbnRlcnNlY3Rpb25SZWN0Iiwicm9vdEJvdW5kcyIsImNhbGxiYWNrcyIsInB1c2giLCJ1bm9ic2VydmUiLCJzcGxpY2UiLCJpbmRleE9mIiwibGVuZ3RoIiwiZGVsZXRlIiwic2l6ZSIsImRpc2Nvbm5lY3QiLCJpc1BsYWluQ2hpbGRyZW4iLCJwcm9wcyIsImNoaWxkcmVuIiwiSW5WaWV3IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJfX3B1YmxpY0ZpZWxkIiwibm9kZSIsInRyaWdnZXJPbmNlIiwic2tpcCIsInNldFN0YXRlIiwiaW5pdGlhbEluVmlldyIsImxhc3RJblZpZXciLCJvYnNlcnZlTm9kZSIsInByZXZpb3VzSW5WaWV3Iiwib25DaGFuZ2UiLCJzdGF0ZSIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50RGlkVXBkYXRlIiwicHJldlByb3BzIiwicm9vdE1hcmdpbiIsImRlbGF5IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJfdW5vYnNlcnZlQ2IiLCJoYW5kbGVDaGFuZ2UiLCJyZW5kZXIiLCJyZWYiLCJoYW5kbGVOb2RlIiwiYXMiLCJjcmVhdGVFbGVtZW50IiwidXNlSW5WaWV3Iiwic2V0UmVmIiwiUmVhY3QyIiwidXNlU3RhdGUiLCJ1c2VSZWYiLCJsYXN0SW5WaWV3UmVmIiwiY3VycmVudCIsInVzZUVmZmVjdCIsImVudHJ5VGFyZ2V0IiwicHJldmlvdXNFbnRyeVRhcmdldCIsInJlc3VsdCIsIl9iIiwidXNlU3luY0VmZmVjdCIsIlJlYWN0MyIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZU9uSW5WaWV3Iiwib25JbnRlcnNlY3Rpb25DaGFuZ2UiLCJvbkludGVyc2VjdGlvbkNoYW5nZVJlZiIsIm9ic2VydmVkRWxlbWVudFJlZiIsIm9ic2VydmVyQ2xlYW51cFJlZiIsInVzZUNhbGxiYWNrIiwiY2xlYW51cEV4aXN0aW5nIiwiY2xlYW51cCIsImRlc3Ryb3llZCIsImRlc3Ryb3lPYnNlcnZlciIsInN0b3BPYnNlcnZpbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/react-intersection-observer/dist/index.mjs\n");

/***/ })

};
;