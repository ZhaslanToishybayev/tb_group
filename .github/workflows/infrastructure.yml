name: Infrastructure Deployment

on:
  push:
    branches: [main, develop]
    paths:
      - 'terraform/**'
      - 'k8s/**'
      - 'helm/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - dev
          - staging
          - production
      action:
        description: 'Action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  TERRAFORM_VERSION: 1.6.0
  HELM_VERSION: 3.13.0
  KUBECTL_VERSION: 1.28.0

jobs:
  terraform:
    name: Terraform Infrastructure
    runs-on: ubuntu-latest
    if: github.event.inputs.action == 'destroy' || contains(github.event.head_commit.message, '[tf-skip]') == false

    permissions:
      id-token: write
      contents: read
      pull-requests: write

    defaults:
      run:
        working-directory: ./terraform

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: eu-central-1

      - name: Terraform Init
        id: init
        run: |
          terraform init \
            -backend-config="environments/${{ github.event.inputs.environment || 'staging' }}/backend.tfvars" \
            -reconfigure

      - name: Terraform Format
        id: fmt
        run: terraform fmt -check -recursive

      - name: Terraform Validate
        id: validate
        run: terraform validate -no-color

      - name: Terraform Plan
        id: plan
        if: github.event.inputs.action == 'plan' || github.event.inputs.action == '' || github.event.inputs.action == 'apply'
        run: terraform plan -input=false -out=tfplan
        env:
          TF_VAR_environment: ${{ github.event.inputs.environment || 'staging' }}

      - name: Terraform Apply
        id: apply
        if: github.event.inputs.action == 'apply' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
        run: |
          terraform apply -auto-approve tfplan
          echo "id=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
          echo "endpoint=$(terraform output -raw cluster_endpoint)" >> $GITHUB_OUTPUT

      - name: Update kubeconfig
        if: github.event.inputs.action == 'apply'
        run: |
          aws eks update-kubeconfig \
            --region eu-central-1 \
            --name ${{ steps.apply.outputs.id }}

      - name: Terraform Destroy
        id: destroy
        if: github.event.inputs.action == 'destroy' && github.ref == 'refs/heads/main'
        run: terraform destroy -auto-approve
        env:
          TF_VAR_environment: ${{ github.event.inputs.environment || 'staging' }}

  helm-deploy:
    name: Helm Deployment
    runs-on: ubuntu-latest
    needs: terraform
    if: github.event.inputs.action == 'apply' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: eu-central-1

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Get cluster name
        run: |
          echo "CLUSTER_NAME=$(terraform -chdir=terraform output -raw cluster_name)" >> $GITHUB_ENV
        env:
          TF_WORKING_DIR: terraform

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region eu-central-1 \
            --name ${{ env.CLUSTER_NAME }}

      - name: Add Helm repositories
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo update

      - name: Create namespace
        run: |
          kubectl create namespace tbgroup --dry-run=client -o yaml | kubectl apply -f -
          kubectl create namespace monitoring --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy application
        run: |
          helm upgrade --install tbgroup ./helm/tbgroup \
            --namespace tbgroup \
            --create-namespace \
            --set environment=${{ github.event.inputs.environment || 'staging' }} \
            --wait \
            --timeout 15m

      - name: Deploy monitoring
        run: |
          helm upgrade --install tbgroup-monitoring prometheus-community/kube-prometheus-stack \
            --namespace monitoring \
            --create-namespace \
            --set grafana.adminPassword=admin \
            --wait \
            --timeout 10m

  k8s-deploy:
    name: Kubernetes Direct Deployment
    runs-on: ubuntu-latest
    if: contains(github.event.head_commit.message, '[k8s]')
    needs: terraform

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: eu-central-1

      - name: Get cluster name
        run: |
          echo "CLUSTER_NAME=$(terraform -chdir=terraform output -raw cluster_name)" >> $GITHUB_ENV

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region eu-central-1 \
            --name ${{ env.CLUSTER_NAME }}

      - name: Deploy with kustomize
        run: |
          kubectl apply -k k8s/overlays/${{ github.event.inputs.environment || 'staging' }}

  backup:
    name: Database Backup
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    needs: helm-deploy

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: eu-central-1

      - name: Create backup
        run: |
          echo "Creating database backup..."
          # Add backup commands here
          DATE=$(date +%Y%m%d_%H%M%S)
          echo "backup_date=$DATE" >> $GITHUB_ENV
          # Example: kubectl exec -n tbgroup deployment/tbgroup-api -- pg_dump ...

      - name: Upload to S3
        run: |
          echo "Uploading backup to S3..."
          # Add S3 upload commands here
          # aws s3 cp backup.sql s3://tbgroup-backups/

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  notification:
    name: Send Notification
    runs-on: ubuntu-latest
    needs: [helm-deploy, backup, security-scan]
    if: always()

    steps:
      - name: Notify on success
        if: needs.helm-deploy.result == 'success' && needs.backup.result == 'success' && needs.security-scan.result == 'success'
        run: |
          echo "Deployment successful!"
          # Add notification logic (Slack, Email, etc.)

      - name: Notify on failure
        if: needs.helm-deploy.result == 'failure' || needs.backup.result == 'failure' || needs.security-scan.result == 'failure'
        run: |
          echo "Deployment failed!"
          # Add notification logic (Slack, Email, etc.)
